from capstone import *

def disassemble_executable(file_path):
    md = Cs(CS_ARCH_X86, CS_MODE_32)

    with open(file_path, 'rb') as file:
        binary_code = file.read()

    disassembly = []
    for instruction in md.disasm(binary_code, 0x0):
        disassembly.append((instruction.address, instruction.mnemonic, instruction.op_str))

    return disassembly

def make_control_flow_graph(disassembly):
    control_flow_graph = {}

    current_block = []
    for address, mnemonic, op_code in disassembly:
        current_block.append((address, mnemonic, op_code))

        if mnemonic.startswith('j') or mnemonic.startswith('call'):
            control_flow_graph[tuple(current_block)] = address
            current_block = []

    if current_block:
        control_flow_graph[tuple(current_block)] = None

    return control_flow_graph

def print_control_flow_graph(control_flow_graph):
    for block, target_address in control_flow_graph.items():
        print(f"Block: {block}")
        print(f"Target Address: {target_address}")
        print("\n")

file_path = ""#enter file path here
disassembly = disassemble_executable(file_path)
control_flow_graph = make_control_flow_graph(disassembly)
print_control_flow_graph(control_flow_graph)